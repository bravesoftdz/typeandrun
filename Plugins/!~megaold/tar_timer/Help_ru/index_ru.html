<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>О плагине tar_timer</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>
<body>
 <center>
 <h1>Планировщик и таймер с возможностью индикации оставшегося времени</h1>
 <h2>Версия: 1.4</h2>
 </center>
 <h2>Автор: Python &lt;smisoft@rambler.ru&gt; (c) SmiSoft (SA)</h2>
 <h3>Что это такое:</h3>
 <p>Есть целая серия программ-таймеров, которые по истечению определенного
 времени теребят пользователя, или выполняют какое-то задание. Например, чтобы
 не забыть про время, играя в интересную игру.
 <p>Есть целая серия программ, выполняющих заданное действие в определенное
 время. Самый популярный пример таких программ - программа Назначенные задания
 (поставляется вместе с любой версией Windows и по умолчанию висит в трее в виде
 окошечка с часиками в левом нижнем углу, или работает как сервис в Windows NT/2000/XP).
 <p>Вначале я реализовал плагин, выполняющий только первую функцию, но потом
 (по немногочисленным просьбам) написал продолжение плагина, реализующего также
 и вторую функцию. За базу я принял великолепную программу nnCron (ее легко
 найти в интернете и она бесплатна для русских пользователей).
 <h3>Возможности:</h3>
 <p>Выводит заданное текстовое сообщение через определенное время, либо
 запускает указанную программу с параметрами, либо показывает заданное On
 Screen Display сообщение.
 <p>Может показывать оставшееся время на обычных часах (круглых). Показывается
 только первый таймер из всех, что требуют показа времени (после смерти первого
 таймера, очередь перейдет к следующему).
 <p>Может выполнять задания по расписанию. Время задается в формате Cron.
 <p>Четыре типа заданий: <i>/msg</i> - вывод модального сообщения, <i>/osd</i>
 - показ On Screen Display сообщения, <i>/run</i> - запуск программы, <i>/tar</i>
 - выполнение алиаса TaR.
 <h3>Как пользоваться:</h3>
 <h4>Основные понятия Cron (ВАЖНО!)</h4>
 <p>При описании алиасов будет использоваться слово Cron. Что же это такое?
 <p>Формат Cron изначально был придуман для одноименной программы Cron под Unix.
 Программа оказалась столь удачной, что вскоре появились ее многочисленные
 клоны. Мой плагин также относится к этим клонам (пусть и очень далеким от
 оригинала).
 <p>Время Cron представляет собой строку из 6 блоков:
 <p><i>минуты часы дни месяцы дни_недели годы</i>
 <p>Каждый блок задает множество возможных значений, или диапазонов, например:
 "<i>0,1,5-10</i>", или спецсимвол <i>*</i>, означающий все возможные значения.
 Конечные блоки, содержащие лишь <i>*</i> можно опускать. Например, "<i>10 12</i>"
 означает 12 часов 10 минут в любой день.
 <p>Формат Cron требует указывать номера дней недели. Воскресенье имеет номер
 0, дни с понедельника по субботу - соответственно от 1 до 6.
 <p>Дата удовлетворяет условию (и соответствующее задание выполняется) тогда и
 только тогда, когда соответствующие поля даты удовлетворяют полям Cron.
 Например, строка "<i>0 20 * * 0,6</i>" вынуждает плагин выполнять задание в
 8:00 вечером по выходным.
 <h4>Основные понятия задания (ВАЖНО!)</h4>
 <p>При описании алиасов будет использоваться термин Задание. Что же это такое?
 <p>Плагин поддерживает на данный момент четыре типа заданий:
 <ul>
 <li><i>/msg Строка</i>
 <br>Выводит сообщение в модальном окошке. В строке могут использоваться спецсимволы:
 <br><i>\n</i> - перенос строки
 <br><i>\t</i> - табуляция
 <br><i>\\</i> - символ \
 <li><i>/run Имя_программы параметры</i>
 <br>или
 <br><i>/run "Имя программы с пробелами" параметры</i>
 <br>Запускает программу с заданными параметрами. Рабочий каталог - текущий.
 <li><i>/osd Строка</i>
 <br>Показывает сообщение посредине экрана на контрастном фоне на одну секунду.
 Функция еще не слишком отлажена, но при работе в обычном режиме (то есть не в
 полноэкранном приложении типа игр) работает вполне удовлетворительно).
 <li>/<i>tar Строка</i>
 <br>Передает указанную строку для выполнения в TaR через стандартный интерфейс.
 </ul>
 Если ключ не указан, или время указано ошибочно, то расписание не будет установлено,
 зато будет отображено уведомление.
 <h3>Алиасы:</h3>
 <ul>
  <li><i>~SetTimer ЧЧ:ММ:СС [номер] [/a] [/loop] [/late] [/start] задание</i>
  <br>Установка или модификация прежнего таймера.
  <ul>
   <li><i>ЧЧ:ММ:СС</i> - время, через которое сработает таймер.
   <br>Можно задавать в виде <i>ЧЧ:ММ:СС</i> (например <i>3:0:7</i> - сработает
    через 3 часа 7 секунд) или <i>ММ:СС</i> (например, <i>7:</i> - сработает
    ровно через 7 минут) или <i>СССС</i> (например, <i>600</i> - сработает через
    600 секунд (10 минут))
   <br>Как видно из примеров, ведущие нули можно пропускать и даже можно пропускать
   нулевые значения параметров (например, первый пример можно записать как
   <i>3::7</i>, хотя это и непривычно).
   <br>Нельзя завести таймер на 0 секунд, или пропустить время вообще - таймер
   не установится, а вы будете оповещены об ошибке.
   <li><i>номер</i> - можно изменить поведение уже установленного таймера,
   если известен его номер, либо установить таймер с известным номером. Если
   параметр пропущен, используется таймер с номером 0. Особенность данного таймера
   - нельзя получить информацию о нем с помощью ~gettimer, а "~killtimer 0" убивает
   последний установленный таймер с номером 0. Также нельзя редактировать таймер с
новером 0 вызовом ~settimer
   <li><i>/a</i> означает, что вы увидите в правом верхнем углу круглые часики,
   показывающие привычными стрелочками, сколько времени осталось до срабатывания.
   Это - не окошечко, а картинка, поэтому ее нельзя передвигать, зато она не
   мешает нажимать на кнопки, расположенные под ней (и не занимает место в памяти)
   <li><i>/loop</i> - создает циклический таймер, то есть он будет вызывать указанное
   действие через указанный период. Функция может пригодиться, например если вы
   хотите каждый час делать перерыв (для сохранения вашего зрения).
   <li><i>/Late</i> - позволяет выполнить действие таймера, как только это станет
   возможным. То есть вы можете отключить компьютер, таймер (который должен был
   выполниться пока компьютер был отключен) сработает сразу по загрузке плагина.
   <li><i>/Start</i> - полезен, только если указан ключ <i>/Loop</i> и <i>/Late</i>.
   Если таймер не сработал в назначенное время, то он сработает сразу по запуску 
   плагина (правило <i>/Late</i>), а следующий запуск (правило <i>/Loop</i>)
   произойдет либо в точности через указанное время (если <i>/Start</i> указан),
   либо в то время, как если бы все таймеры сработали.
   <br>Например, в 13:00 вы завели таймер на 1 час (циклический). Таймер сработал
   в 14:00, затем компьютер был выключен и включился только в 17:30. Если ключ
   <i>/Late</i> был указан, то таймер сработает немедленно. Если ключ <i>/Start</i>
   был указан, то следующее срабатывание произойдет в 18:30, если же нет - то
   в 18:00 (как если бы таймер в 15:00, 16:00 и 17:00 сработал). Указывать или
   нет данный ключ - зависит от типа выполняемой задачи.
  </ul>
  Примеры употребления:
  <ul>
   <li>~SetTimer 600 /a /msg Отключить чайник
    <br>если хотите кипятить чайник 10 минут. Или такой:
   <li>~SetTimer 3:: /run C:\Programs\TerminateHalfLife.exe
    <br>если нужно, чтобы таймер оторвал вас от интересной игры и чтобы его не было видно.
  </ul>
  Особенность: ключи /a могут быть указаны для нескольких таймеров одновременно,
  но видно будет только первый из них (имеется в виду, который раньше установили).
  Если его уничтожить вызовом ~killtimer, или он сам умрет по истечению времени,
  или если скрыть его вызовом ~settimer без /a, то будет виден следующий таймер.
  <li><i>~KillTimer [номер]</i>
   <br>Уничтожает заведенный таймер с указанным номером, или все заведенные таймеры
   (как скрытые, так и видимые), если номер не указан.
  <li><i>~GetTimer [номер]</i>
   <br>Показывает информацию о таймере с указанным номером, или сколько и
   каких таймеров у вас заведено.
   <center><img src="timer_ru.gif"></center>
   <ol>
    <li>идентификатор таймера
    <li>команда, выполняющаяся при срабатывании
    <li>сколько времени осталось до ближайшего срабатывания
   </ol>
  <li><i>~SetShed Идентификатор Cron [/Late] Задание</i>
   <br>Устанавливает расписание.
   <ul>
    <li><i>Идентификатор</i> - любая непустая строка, составленная из букв,
    цифр и знаков препинания в любой комбинации (запрещены только пробелы и
    табуляции)
    <li><i>Cron</i> - время срабатывания.
    <li><i>/Late</i> - означает, что задание будет выполнено как только будет
    возможность. Новая функция, может не работать 29 февраля.
    <li><i>Задание</i> - любое записанное в соответствии с указанными выше
    правилами задание.
   </ul>
  <li><i>~KillShed [Идентификатор]</i>
   <br>Убивает расписание с заданным идентификатором, либо все расписания по
   запросу, если идентификатор не задан.
  <li><i>~GetShed [Идентификатор]</i>
   <br>Показывает информацию о расписании с заданным идентификатором, или
   выводит диалоговое окно, позволяющее редактировать список существующих
   расписаний с комфортом. Надеюсь, объяснения не нужны. Для упрощения
   редактирования в списках существуют контекстные меню - оцените.
   <center><img src="shed_ru.gif"></center>
   <ol>
    <li>Общий список заданий. Щелкните по заданию для просмотра его параметров
    <li>Имя задания (идентификатор). Если укажете в имени пробел, не сможете
    удалить потом задание по команде ~KillShed, только из редактора. Других
    ограничений нет.
    <li>Строка, записанная в формате <i>Cron [флаги] задание</i>. Можно редактировать
    непосредственно ее, или визуальное представление (ниже).
    <li>Преобразовать визуальное представление в Cron. Обновляет содержимое поля
    3 в соответствии с изменениями визуальных полей.
    <li>Преобразовать Cron в визуальное представление. Обновляет визуальные поля
    в соответствии с изменениями поля Cron. При переключении элементов в списке
    1 поле Cron и визуальные поля соответствуют друг другу.
    <li>Визуальные поля редактирования даты. Отметьте галочками то условие, при
    выполнении которого должно выполняться задание.
    <li>То же, что флаг /Late
    <li>Левая кнопка (+) добавляет новую запись с указанными параметрами в список.
    Используется то представление (визуальное или Cron) которое последним было
    исправлено. Правая кнопка (-) удаляет выделенную запись.
    <li>Показывает тип выполняемого задания
    <li>Показывает параметр (зависит от типа выполняемого задания) - сообщение,
    программу с параметрами или передаваемую в TaR команду.
    <li>Сохраняет сделанные изменения. Также можно принять изменения нажатием
    Enter в полях редактирования
    <li> Выход без сохранения изменений. Также можно выйти по нажатию на Esc.
   </ol>
  <li><i>~SetLoad [номер] [/1] [/timeout время] задание</i>
   <br>Устанавливает задание, выполняемое при загрузке системы (вроде папки Автозагрузка,
   но удобнее).
   <br><b>Параметры:</b>
   <ul>
    <li><i>номер</i> - используется только для редактирования существующего задания.
    Каждому заданию соответствует свой номер (от 1 до 25).
    <li><i>/1</i> - означает однократное выполнение задания. После выполнения,
    будет автоматически удалено.
    <li><i>/timeout время</i> - задает, через какое время после выполнения предыдущего
    задания произойдет срабатывание этого задания. Папка Автозагрузка обычно запускает
    все ярлыки подряд - флаг timeout дает возможность избежать такого хаоса.
    <li><i>задание</i> - любое задание.
   </ul>
  <li><i>~KillLoad [номер]</i>
   <br>Убивает задание с заданным номером. Если номер не указан - убивает все задания
    (без предупреждения!)
  <li><i>~GetLoad</i>
   <br>Показывает все назначенные на загрузку задания с номерами.
  <li><i>~SetUnLoad [номер] [/1] [/timeout время] задание</i>
   <br>То же, что ~SetLoad, но выполняется при зывершении работы системы
  <li><i>~KillUnload [номер]</i>
   <br>То же, что ~KillLoad, но для заданий, назначенных на завершение работы.
  <li><i>~GetUnload</i>
   <br>Показывает все назначенные на завершение работы задания.
  <li><i>~ForgetCD [параметр]</i>
   <br>Функция-незабудка. Выбросит диск из CD привода, если вы попытаетесь отключить
   компьютер и оставите там диск. Параметры:
   <ul>
    <li>нет параметров - показать статус незабудки
    <li>0 - отключить незабудку
    <li>1 - включить незабудку
   </ul> 
 </ul>
 <h3>Особенности:</h3>
 <ul>
  <li>При высокой загрузке системы окна таймеров могут не обновляться. Это не
  проблема, а особенность, так как в целях экономии ресурсов системы я установил
  таймеру наименьший приоритет. По истечении времени, таймер сработает сразу,
  как это только станет возможным.
  <li>Расписания и активные таймеры сохраняются в файле имя_плагина.ini.
 </ul>
 <b><font size=+1 color=blue>История:</font></b>
 <br><font color=green>[+]</font>&nbsp;Новая фича
 <br><font color=blue>[*]</font>&nbsp;Пофиксен баг
 <br><font color=red>[-]</font>&nbsp;Убрана фича
 
 <p><font size=+1 color=blue>Версия 1.0 - 03.02.05</font>
 <br><font color=green>[+]</font>&nbsp;Первая рабочая версия плагина

 <p><font size=+1 color=blue>Версия 1.1 - 05.02.05</font>
 <br><font color=green>[+]</font>&nbsp;Появилась возможность переустанавливать время таймера через командную строку
 <br><font color=green>[+]</font>&nbsp;Появилось несколько новых алиасов (см. описание)
 <br><font color=green>[+]</font>&nbsp;Появились новые ключи (/msg и /run)
 <br><font color=red>[-]</font>&nbsp;Убрано контекстное меню таймера
 <br><font color=blue>[*]</font>&nbsp;Решена проблема с передвижением окна часиков
 <br><font color=blue>[*]</font>&nbsp;Переработан алгоритм анализа командной строки
 <br><font color=blue>[*]</font>&nbsp;Исходный код переписан под Delphi 3.0 и теперь не использует runtime библиотек.

 <p><font size=+1 color=blue>Версия 1.1 final - 06.02.05</font>
 <br><font color=blue>[*]</font>&nbsp;Исправлен небольшой недочет интерфейса - серая полоска справа от аналогового таймера.
 <br><font color=blue>[*]</font>&nbsp;Убран заголовок окна у цифрового таймера
 <br><font color=blue>[*]</font>&nbsp;Исправлен сбой, возникавший при выходе их TypeAndRun при активномм таймере под Windows 2000

 <p><font size=+1 color=blue>Версия 1.2 - 04.05.05</font>
 <br><font color=green>[+]</font>&nbsp;Появилась возможность создавать расписания (то есть запускать задачи, например, в 12:30). Это - самое основное отличие.
 <br><font color=green>[+]</font>&nbsp;Появился новый ключ /osd (как для команды ~settimer, так и для ~setshed) - это позволяет на одну секунду показывать посредине экрана указанный текст. "Фирменный" алгоритм для создания настоящих On Screen Display сообщений мне неизвестен, поэтому пришлось писать свой. В играх возможно кратковременное мерцание (без негативных последствий).
 <br><font color=green>[+]</font>&nbsp;Появился новый ключ /tar (как для команды ~settimer, так и для ~setshed) - это позволяет выполнить любую команду TaR, как если бы она была введена в консоли.
 <br><font color=red>[-]</font>&nbsp;Теперь остановить таймер через контекстное меню нельзя. Нельзя также перетаскивать часики - они навеки прикреплены к правому верхнему углу. Зато библиотека занимает меньше места в памяти :-)
 <br><font color=red>[-]</font>&nbsp;Ключ /d убран
 <br><font color=blue>[*]</font>&nbsp;Убрано ограничение на длину строки - раньше 255 символов, теперь 65535. Впрочем, это вряд ли кто оценит :-)
 <br><font color=blue>[*]</font>&nbsp;Теперь номер таймера не соответствует его физическому размещению в очереди, а лишь используется при вызове команд ~gettimer и ~killtimer
 <br><font color=blue>[*]</font>&nbsp;Команда ~settimer, явно заданная с идентификатором, модифицирует указанный таймер.
 <br><font color=blue>[*]</font>&nbsp;Плагин переписан на Delphi 6.0. С Run-time библиотеками - мне места на диске жалко :-(. Если надо - можно перекомпилировать - исходники доступны.

 <p><font size=+1 color=blue>Версия 1.3 - 29.06.05</font>
 <br><font color=green>[+]</font>&nbsp;Наконец то таймеры сохраняются.
 <br><font color=green>[+]</font>&nbsp;Изменен интерфейс редактора. Теперь - более удобный и Windows XP совместимый интерфейс.
 <br><font color=green>[+]</font>&nbsp;Теперь все сообщения полностью локализуются из INI файла.
 <br><font color=green>[+]</font>&nbsp;Теперь выдаются сообщения об ошибках.
 <br><font color=red>[-]</font>&nbsp;Удалена команда ~StoreShed. Теперь сохранение происходит автоматически при выховах редакторов. Тем не менее, при обычном срабатывании таймеров и расписаний записи не происходит, поэтому после ошибочных завершений работы плагина возможны ложные срабатывания расписаний и таймеров с проставленным флагом /Late (обработка опоздавших событий)
 <br><font color=blue>[*]</font>&nbsp;Добавлена возможность обработки опоздавших событий. Эта функция включается ключом /late или соответствующим флагом в окне редактирования.
 <br><font color=blue>[*]</font>&nbsp;Новые ключи /late, /start, /loop
 <br><font color=blue>[*]</font>&nbsp;Версия без использования сторонних библиотек

 <p><font size=+1 color=blue>Версия 1.4 - 03.07.05</font>
 <br><font color=green>[+]</font>&nbsp;Выполнение заданий при загрузке и завершении работы компьютера.
 <br><font color=green>[+]</font>&nbsp;Незабудка: не позволит вам забыть диск в приводе
 <br><font color=green>[+]</font>&nbsp;Теперь OSD работает и в полноэкранных играх
</body>
</html>
